# Scope Functions в Kotlin

## Реализации Scope Functions

### `myLet`
```kotlin
inline fun <T, R> T.myLet(block: (T) -> R) : R {
    return block(this)
}
```

### `myAlso`
```kotlin
inline fun <T> T.myAlso(block: (T) -> Unit) : T {
    block(this)
    return this 
}
```

### `myApply`
```kotlin
inline fun <T> T.myApply(block: T.() -> Unit) : T {
    block()
    return this
}
```

### `run`
```kotlin
inline fun <T, R> T.run(operation: T.() -> R) : R {
    return operation()
}
```

### `myWith`
```kotlin
inline fun <T, R> T.myWith(block: T.() -> R) : R {
    return block()
}
```

---

## Вопросы с собеседования

### ❓ Какие из этих функций в качестве параметра принимают лямбду с ресивером?

**Ответ:** `run`, `with` и `apply`

> Лямбда с ресивером (`T.() -> R`) позволяет обращаться к свойствам и методам объекта напрямую через `this` без явного указания объекта.

---

### ❓ Какие из этих функций возвращают результат лямбды?

**Ответ:** `let`, `run` и `with`

> Эти функции возвращают результат выполнения лямбда-выражения, а не сам объект.

---

### ❓ Какие из этих функций в качестве параметра принимают лямбду с аргументом?

**Ответ:** `let` и `also` (остальные принимают лямбду с ресивером)

> Лямбда с аргументом `(T) -> R` принимает объект как параметр, что позволяет использовать его под другим именем (например, `it`).

---

### ❓ Какие из следующих функций являются extension-функциями?

**Ответ:** Все кроме `with`

> `with` - это обычная функция, которая принимает объект как первый параметр. Остальные функции (`let`, `run`, `apply`, `also`) являются extension-функциями.

---

## Сравнительная таблица

| Функция | Тип лямбды | Возвращает | Extension? |
|---------|-----------|------------|------------|
| `let` | `(T) -> R` | Результат лямбды | ✅ |
| `run` | `T.() -> R` | Результат лямбды | ✅ |
| `with` | `T.() -> R` | Результат лямбды | ❌ |
| `apply` | `T.() -> Unit` | Сам объект | ✅ |
| `also` | `(T) -> Unit` | Сам объект | ✅ |
